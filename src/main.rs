use async_openai::{
    types::{ChatCompletionRequestMessageArgs, CreateChatCompletionRequestArgs, Role},
    Client,
};

use actix_web::{middleware, web, App, HttpResponse, HttpServer, Responder};

use serde::Deserialize;
use serde_json::json;
use tokio_postgres::NoTls;

#[macro_use]
extern crate log;

#[derive(Deserialize)]
struct FormData {
    text: String,
    tags: String,
}

async fn insert_question_and_variants(form: web::Json<FormData>) -> impl Responder {
    let (client, connection) = tokio_postgres::connect(
        "postgresql://strickvl:alex@localhost:5432/mathsprompt",
        NoTls,
    )
    .await
    .unwrap();

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    let tags: Vec<&str> = form.tags.split(',').collect();

    let mut tag_ids: Vec<i32> = Vec::new();
    for tag in tags {
        let rows = client
            .query("SELECT id FROM tags WHERE name = $1", &[&tag])
            .await
            .unwrap();
        if rows.is_empty() {
            let row = client.query_one("INSERT INTO tags (name, created_at, updated_at) VALUES ($1, NOW(), NOW()) RETURNING id", &[&tag]).await.unwrap();
            let tag_id: i32 = row.get(0);
            tag_ids.push(tag_id);
        } else {
            let tag_id: i32 = rows[0].get(0);
            tag_ids.push(tag_id);
        }
    }

    // New code to generate variants
    let openai_client = Client::new();
    let prompt = format!("I have this question:\n\n\"\"\"\n{}\n\"\"\"\n\nAnd I need you to generate 10 new questions that are similar in form, but with different values / variables (as is appropriate). The first line should be the question above but reformatted and reworded if necessary to make it clear.\n\nThen give me the 10 generated questions. (So there should be 11 questions at the end). Don't explain yourself beforehand. Your response should only be a numbered list of questions.", form.text);

    let request = CreateChatCompletionRequestArgs::default()
        .max_tokens(512_u16)
        .model("gpt-3.5-turbo")
        .messages([
            ChatCompletionRequestMessageArgs::default()
                .role(Role::System)
                .content("You are a helpful assistant with experience as a Maths teacher for over 10 years.")
                .build().unwrap(),
            ChatCompletionRequestMessageArgs::default()
                .role(Role::User)
                .content(&prompt)
                .build().unwrap(),
        ])
        .build().unwrap();

    let response = openai_client.chat().create(request).await.unwrap();
    let mut questions_added = 0;

    for (i, choice) in response.choices.iter().enumerate() {
        // Check if content is Some(String)
        if let Some(content) = &choice.message.content {
            // Split the text into lines
            let lines: Vec<&str> = content.trim().split('\n').collect();
            questions_added += lines.len();
            for line in lines {
                // Remove the number prefix
                let new_question_text = line
                    .trim_start_matches(|c: char| c.is_numeric() || c == '.' || c == ' ')
                    .trim();

                // Determine if the question is autogenerated or not
                let autogenerated = i != 0;

                // Insert the new question into the database
                let row = client.query_one("INSERT INTO questions (text, next_due, autogenerated, created_at, updated_at) VALUES ($1, NOW(), $2, NOW(), NOW()) RETURNING id", &[&new_question_text, &autogenerated]).await.unwrap();
                let new_question_id: i32 = row.get(0);

                // Insert the same tags into the question_tag table for this new question
                for tag_id in &tag_ids {
                    client.execute("INSERT INTO question_tag (question_id, tag_id, created_at, updated_at) VALUES ($1, $2, NOW(), NOW())", &[&new_question_id, tag_id]).await.unwrap();
                }
            }
        }
    }
    info!(
        "Added {} questions and {} tags to the database",
        questions_added,
        tag_ids.len()
    );

    HttpResponse::Ok().body("Question and variants added successfully!")
}

async fn get_random_question() -> impl Responder {
    let (client, connection) = tokio_postgres::connect(
        "postgresql://strickvl:alex@localhost:5432/mathsprompt",
        NoTls,
    )
    .await
    .unwrap();

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    let row = client
        .query_one("SELECT * FROM questions ORDER BY RANDOM() LIMIT 1", &[])
        .await
        .unwrap();
    let question_text: String = row.get("text");

    println!("Sending question: {}", question_text); // Logging the question for debugging

    HttpResponse::Ok().json(json!({ "text": question_text })) // return a JSON object
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init();
    HttpServer::new(move || {
        App::new()
            .wrap(
                middleware::DefaultHeaders::new()
                    .add(("Access-Control-Allow-Origin", "*"))
                    .add(("Access-Control-Allow-Methods", "GET, POST"))
                    .add(("Access-Control-Allow-Headers", "Content-Type")),
            )
            .route("/", web::post().to(insert_question_and_variants))
            .route("/random", web::get().to(get_random_question))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
